# 第二章 变量和基本类型

 ***从右向左阅读明确定义*** 对定义的明确方法 从右向左阅读 某个变量到底是什么。

 const double *const pip = &pi;

 pip 是个常量，且是一个常量指针。 指向的是一个双精度浮点常量。

C++ 静态数据类型语言，类型检查发生在编译时

### 基本内置类型

**基本算数类型**：

| 类型 | 含义 | 最小尺寸|
|---|---|---|
| `bool` | 布尔类型  | 8bits |
| `char`| 字符 | 8bits |
| `wchar_t` | 宽字符 | 16bits |
| `char16_t` | Unicode字符 | 16bits |
| `char32_t` | Unicode字符 | 32bits |
| `short` | 短整型 | 16bits |
| `int` | 整型 | 16bits (在32位机器中是32bits) |
| `long` | 长整型 | 32bits |
| `long long` | 长整型 | 64bits （是在C++11中新定义的） |
| `float` | 单精度浮点数 | 6位有效数字 |
| `double` | 双精度浮点数 | 10位有效数字 |
| `long double` | 扩展精度浮点数 | 10位有效数字 |


### 如何选择类型

- 1.当明确知晓数值不可能是负数时，选用无符号类型；
- 2.使用`int`执行整数运算。一般`long`的大小和`int`一样，而`short`常常显得太小。除非超过了`int`的范围，选择`long long`。
- 3.算术表达式中不要使用`char`或`bool`。
- 4.浮点运算选用`double`。

### 类型转换

- 非布尔型赋给布尔型，初始值为0则结果为false，否则为true。
- 布尔型赋给非布尔型，初始值为false结果为0，初始值为true结果为1。

### 字面值常量

- 一个形如`42`的值被称作**字面值常量**（literal）。
  - 整型和浮点型字面值。
  - 字符和字符串字面值。
    - 使用空格连接，继承自C。
    - 字符字面值：单引号， `'a'`
    - 字符串字面值：双引号， `"Hello World""`
  - 转义序列。`\n`、`\t`等。
  - 布尔字面值。`true`，`false`。
  - 指针字面值。`nullptr`

## 变量

**变量**提供一个**具名**的、可供程序操作的存储空间。   `C++`中**变量**和**对象**一般可以互换使用。

### 变量定义（define）

- **定义形式**：类型说明符（type specifier） + 一个或多个变量名组成的列表。如`int sum = 0, value, units_sold = 0;`

***
- **初始化**（initialize）：对象在创建时获得了一个特定的值。
  - *** 初始化不是赋值！***：
  - 初始化 = 创建变量 + 赋予初始值
  - 赋值 = 擦除对象的当前值 + 用新值代替
  - **列表初始化**：使用花括号`{}`，如`int units_sold{0};` 这个是列表初始化 C++ 11 标准
  - 默认初始化：定义时没有指定初始值会被默认初始化；在函数体内部的内置类型变量将不会被初始化，定义在函数体外的值被初始化为0.类对象的value没有被显示初始化，其value由类来决定。
  - 建议初始化每一个内置类型的变量。 否则可能会产生程序错误
***
### 变量的**声明**（declaration） vs **定义**（define）
  - 为了支持分离式编译，`C++`将声明和定义区分开。**声明**使得名字为程序所知。**定义**负责创建与名字关联的实体。
  - **extern**：只是说明变量定义在其他地方。 extern是声明的意思
   ```c++
   extern int i; //声明
   int i; //定义
    ```
  - 只声明而不定义： 在变量名前添加关键字 `extern`，如`extern int i;`。但如果包含了初始值，就变成了定义：`extern double pi = 3.14;`
  - 变量只能被定义一次，但是可以多次声明。 多次extern语句
  - 在多个文件中使用同一个变量 需要声明定义分离。 多个文件中可以重复声明，但只能定义一次 （minidraw程序见过了）
  - 
## 名字的**作用域**（namescope）
 - 全局作用域
 - 块作用域

## 左值和右值

- **左值**（l-value）**可以**出现在赋值语句的左边或者右边，比如变量；
- **右值**（r-value）**只能**出现在赋值语句的右边，比如常量。


## 复合类型
基于其他类型定义的类型 包括指针和引用

引用是另一个对象的别名，而指针本身就是一个对象。

引用必须初始化，并且一旦定义了引用就无法再绑定到其他对象。而指针无须在定义时赋初值，也可以重新赋值让其指向其他对象。

### 引用

- **引用**：引用是一个对象的别名，引用类型引用（refer to）另外一种类型。如`int &refVal = val;`。
- 引用必须初始化。 
  ```C++
  int &ref_name ；//报错 必须初始化
  ```
- 引用和它的初始值是**绑定bind**在一起的，而**不是拷贝**。 将值赋给与引用绑定了的对象
  ```C++
  int ival = 1024;
  int &refval = ival;
  refval = 2;// 把 2 赋值 给refval指向的对象 ival
  ```
- 引用只能绑定在对象上 不能绑定在值上
  ```C++
  int &ref = 10  ; // 非法的
  ``` 

### 指针

- 是一种 `"指向（point to）"`另外一种类型的复合类型。
- **定义**指针类型： `int *ip1;`，**从右向左读**，`ip1`是指向`int`类型的指针。
- 指针存放某个对象的**地址**。
- 获取对象的地址： `int i=42; int *p = &i;`。 `&`是**取地址符**。p存放了i的地址
- 指针  和他指向的对象的类型严格匹配。
- 指针的值的四种状态：
  - 1.指向一个对象；
  - 2.指向紧邻对象的下一个位置；
  - 3.空指针；
  - 4.无效指针。 引发错误！！！
- 指针访问对象： `cout << *p;`， `*`是**解引用符**。
  ```C++
  int i = 42;
  int *p = &i;
  cout<<*p;
  *p = 0; // 之后 i =0 ；
  ```
- 空指针不指向任何对象。
- `void*`指针可以存放**任意**对象的地址。 无法直接操作void* 指向的对象
- 其他指针类型必须要与所指对象**严格匹配**。
- 两个指针相减的类型是`ptrdiff_t`。
- 建议：初始化所有指针。 初始化为0也可以
- 指针的比较 ： 指向的地址是否相等 p1 == p2；
- 指向指针的引用
  ```C++
  int i =32;
  int *p;
  int *&r = p;//r是对指针p的引用 r是一个引用 &r 且 r引用的是一个指针。

  r = &i; //r引用乐一个指针 因此给r赋值 就是领p指向i
  *r = 0 ; //i =0;
  ```
  ***从右向左阅读明确定义***


## const限定符 还是看书吧 用得不多记不住

- 动机：希望定义一些不能被改变值的变量。
- cosnt会优先修饰左边

```c++
const int * p ; //指向常量的指针 ，指向的对象必须是一个常量，不能被该指针改变，但可以被别的改变。
int * const p; // 常量指针必须被初始化 指针本身是一个常量
```

对const 的 理解 ： 哪个是const，哪个就是不能被改变的。

### 初始化和const
- const对象**必须初始化**，且**不能被改变**。
- const变量默认不能被其他文件访问，非要访问，必须在指定const前加extern。 定义和声明都加extern

### const的引用

- **reference to const**（对常量的引用）：指向const对象的引用，如 `const int ival=1; const int &refVal = ival;`，可以读取但不能修改`refVal`。
- **临时量**（temporary）对象：当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。
- 对临时量的引用是非法行为。
- 对const引用可能引用一个非const的对象

### 指针和const
常量指针和指向常量的指针
- **pointer to const**（指向常量的指针）：不能用于改变其所指对象的值, 只能使用指向常量的指针来存放常量对象的地址。反过来，允许使用指向常量的指针指向非常量的对象 。如 `const double pi = 3.14; const double *cptr = &pi;`。
- **const pointer**：指针本身是常量，如 `int i = 0; int *const ptr = &i;`


***从右向左阅读明确定义***

### 顶层const看书

- `顶层const`：指针本身是个常量。
- `底层const`：指针指向的对象是个常量。拷贝时严格要求相同的底层const资格。

### `constexpr`和常量表达式

- 常量表达式：指值不会改变，且在编译过程中就能得到计算结果的表达式。由数据类型const和初始值决定
    ```c++
      const int sz = get_size(); //就不是一个常量表达式
    ```
- `C++11`新标准规定，允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量的表达式。
- 常量表达式`constexpr`
- `constexpr int *p`只能指向nullptr或者堆里的地址（不会发生改变的地址 不能定义在函数里）

## 处理类型

### 类型别名

- 传统别名：使用**typedef**来定义类型的同义词。 `typedef double wages;`
- 新标准别名：别名声明（alias declaration）： `using SI = Sales_item;`（C++11）

### auto类型说明符

- **auto**类型说明符：让编译器**自动推断类型**。 必须有初始值
- `int i = 0, &r = i; auto a = r;` 推断`a`的类型是`int`。 以引用对象的类型作为auto的类型
- 会忽略`顶层const`。
- `const int ci = 1; const auto f = ci;`推断类型是`int`，需要自己加`const`
- `C++11`
- 不能为非常量引用绑定字面值

### decltype类型指示符

- 从表达式的类型推断出要定义的变量的类型。
- **decltype**：选择并返回操作数的**数据类型**。
- `decltype(f()) sum = x;` 推断`sum`的类型是函数`f`的返回类型。 不实际调用f
- 不会忽略`顶层const`。
- `C++11`
- decltype与引用  向decltype返回一个引用类型，意味着该表达式的对象能作为一条赋值语句的左值

  ```c++
  int i =42 , *p = &i, &r = i;
  decltype(r+0) b;
  decltype(*p) c; //表达式的内容是 解引用 操作，decltype得到引用类型

  decltype(（）) // 双括号永远是应用 因为获得了表达式
  decltype(val) // 只有val是引用的时候才是引用
  ```



## 自定义数据结构

### struct

- 类可以以关键字`struct`开始，紧跟类名和类体。
- 类数据成员：类体定义类的成员。
- `C++11`：可以为类数据成员提供一个**类内初始值**（in-class initializer）。

### 编写自己的头文件

- 头文件通常包含只能被定义一次的实体：类、`const`和`constexpr`变量。

预处理器概述：

- **预处理器**（preprocessor）：确保头文件多次包含仍能安全工作。
- 当预处理器看到`#include`标记时，会用指定的头文件内容代替`#include`
- **头文件保护符**（header guard）：头文件保护符依赖于预处理变量的状态：已定义和未定义。

```cpp
#ifndef SALES_DATA_H// 防止多重定义       
#define SALES_DATA_H
strct Sale_data{
    ...
}
#endif
```
