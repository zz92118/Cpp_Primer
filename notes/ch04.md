# 第四章 表达式

- 运算对象 operand
- 表达式 expression
- 运算符 operator
## 表达式基础

- **重载运算符**：当运算符作用在类类型的运算对象时，用户可以自行定义其含义。
  ***
- **左值和右值**：
    - C中原意：左值**可以**在表达式左边，右值不能。
    - `C++`：当一个对象被用作**右值**的时候，用的是对象的**值**（内容）；
    - 被用做**左值**时，用的是对象的**身份**（在内存中的位置）。
    - 左值：一般有赋值运算、解引用运算、下标运算、迭代器运算符、迭代器递增递减运算
    - 右值：取地址得到的是右值

    ```c++
        假定 p的类型是int* ，
        decltype(*p) //左值 得到 int& （解引用得到指针）
        decltype(&p) //右值 得到int** 取地址 指向指针的指针
    ```
  ***
## 算术运算符

- 算术运算符的运算对象和求值结果都是右值。

- **溢出**：当计算的结果超出该类型所能表示的范围时就会产生溢出。

## 逻辑运算符

- **短路求值**：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。
- 一般做比较运算的时候，不使用布尔字面值true和false作为运算对象。

## 赋值运算符

- 赋值运算的结果是左侧运算对象，是一个左值

- 如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。
- 赋值运算符满足右结合律，这点和其他二元运算符不一样。 `ival = jval = 0;`等价于`ival = (jval = 0);`jval 赋值给了ival
- 赋值运算优先级比较低。
- `while( (i=get_value() != 42 )`

## 递增递减运算符

- 用于迭代器的递增递减
- 前置和后置(都用作于左值运算对象)，前置版本将对象本身作为左值返回，后置版本将对象原始值的副本作为右值返回
- 尽量使用前置版本！！！！！！！！！！

```c++
    int i=0 , j;
    j = ++i; //j=1,i=1
    j = i++; //j=1,i=2 
```

- 在解引用的时候使用后置版本
    
    *pbeg++ 等价于 *(pbeg++) 。因为后置运算返回的是++之前的值，所以肯定不会产生溢出错误。
```c++
    auto pbeg = v.bgein();
    while(pbeg != v.end() && *pbeg >= 0)
    {
        cout << *pbeg++ << endl;pbeg
    }
```

- 递增递减运算符可以按照任意顺序求值 因此需要避免这种情况
    如果改变了某个运算对象的值，不要在表达式的其他地方在使用这个运算对象。

    ```c++
    vec[ival++] <= vec[ival]  
    ```

## 条件运算符

- 条件运算符（`?:`）允许我们把简单的`if-else`逻辑嵌入到单个表达式中去，按照如下形式：`cond? expr1: expr2`

## 位运算符

- 位运算符是作用于**整数类型**的运算对象，因此会对char灯类型进行提升（先转化为int）
- 符号位是未定义的，因此强烈建议只对无符号数进行位运算（符号位的处理方式依赖于机器）
- 二进制位向左移（`<<`）或者向右移（`>>`），移出边界外的位就被舍弃掉了。
- 位取反（`~`）、与（`&`）、或（`|`）、异或（`^`）
- io中的<< 、 >> 是移位运算的重载，他们的优先级是一样的（算数运算 > 移位运算 > 其他运算 关系运算，赋值，条件）

## sizeof运算符

- 返回一条表达式或一个类型名字所占的**字节数**。返回的类型是 `size_t`。
- sizeof满足右结合律
- 两种形式： `sizeof (type)`和 `sizeof expr`

  ```c++
    sales_data * p;
    sizeof(p); //指针的所占空间大小
    sizeof(*p); //指针所指的类型的所占空间大小 即sales_data 的大小
  ```
- sizeof与数组：
  ```c++
  sizeof(ia)// 数组所占空间的大小
  sizeof(*ia)// 数组中每个元素占得空间大小
  sizeof(ia)/sizeof(*ia); //返回了数组元素的数量
  ```

## 逗号运算符

- 按照顺序求值，最终的真正结果是右侧表达式的值。通常用在for循环中

逗号表达式的优先级是最低的。因此这条表达式也等于：
```cpp
(someValue ? ++x, ++y : --x), --y
```
如果`someValue`的值为真，`x` 和 `y` 的值都自增并返回 `y` 值，然后丢弃`y`值，`y`递减并返回`y`值。如果`someValue`的值为假，`x` 递减并返回`x` 值，然后丢弃`x`值，`y`递减并返回`y`值。


## 类型转换

### 隐式类型转换

- 比 `int`类型小的整数值先提升为较大的整数类型。
- 条件中，非布尔转换成布尔。
- 初始化中，初始值转换成变量的类型。赋值语句中，右侧运算对象转化完成左侧运算对象的类型。
- 算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型。
- 函数调用时。

### 显式类型转换（尽量避免）

- **static_cast**：任何明确定义的类型转换，只要不包含底层const，都可以使用。 `double slope = static_cast<double>(j);` 一般将较大类型转化为较小类型
- **dynamic_cast**：支持运行时类型识别。
- **const_cast**：只能改变运算对象的底层const，一般可用于去除const性质。 `const char *pc; char *p = const_cast<char*>(pc)`
- **reinterpret_cast**：通常为运算对象的位模式提供低层次上的重新解释。
